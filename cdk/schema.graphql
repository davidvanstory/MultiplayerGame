# Schema Version: 3.0 - Flexible game system for ANY game type
type Game {
  gameId: ID!
  gameType: String!         # "tictactoe", "chess", "counter", "ai-generated", etc.
  gameHtml: String           # Stored HTML content for the game
  gameState: AWSJSON!        # Flexible JSON for ANY game state
  players: AWSJSON!          # Support N players with flexible structure
  metadata: AWSJSON!         # Game-specific metadata (rules, settings, etc.)
  serverLogicUrl: String     # Lambda ARN for game-specific validation
  conversionStatus: String
  createdAt: String!
  updatedAt: String!
}

input CreateGameInput {
  gameId: ID!
  gameType: String!
  gameHtml: String
  initialState: AWSJSON!
  players: AWSJSON
  metadata: AWSJSON
}

input UpdateGameInput {
  gameId: ID!
  gameState: AWSJSON!
  players: AWSJSON
  metadata: AWSJSON
}

type Query {
  getGame(gameId: ID!): Game
  listGames(gameType: String): [Game!]!
}

type Mutation {
  createGame(input: CreateGameInput!): Game!
  updateGame(input: UpdateGameInput!): Game!
  joinGame(gameId: ID!, playerInfo: AWSJSON!): Game!
  generateGame(gameType: String!, requirements: AWSJSON!): Game!
  convertToMultiplayer(gameId: ID!, gameHtml: String!): Game!
  processGameAction(gameId: ID!, action: AWSJSON!): AWSJSON!
}

type Subscription {
  onGameUpdate(gameId: ID!): Game
    @aws_subscribe(mutations: ["updateGame", "joinGame"])
}